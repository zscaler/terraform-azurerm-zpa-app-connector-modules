#!/usr/bin/env bash

set -eo pipefail

### SET COLOR CODES ###
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
CYAN=$(tput setaf 6)
RESET=$(tput sgr0)

usage()
{
    echo "Usage: $0 <up|destroy>"
    exit 1
}

if [ $# -ne 1 ] ; then
    usage
else
    case $1 in
      up|destroy|do)
          oper=$1
      ;;
      *)
          usage
      ;;
    esac
fi

if [[ "$oper" == "up" && ! -e ./.zsacrc ]]; then
    PS3="${CYAN}Select your ZPA Cloud: ${RESET}"
    zs_clouds=("private.zscaler.com" "zpatwo.net" "zpagov.net" "zpagov.us" "zpabeta.net" "zspreview.net")
    select zscaler_cloud in "${zs_clouds[@]}"
    do
        case $REPLY in
        1)
            echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected..."
            zscaler_cloud=PRODUCTION
        break
        ;;
        2)
            echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected"
            zscaler_cloud=ZPATWO
        break
        ;;
        3)
            echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected"
            zscaler_cloud=GOV
        break
        ;;
        4)
            echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected"
            zscaler_cloud=GOVUS
        break
        ;;
        5)
            echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected"
            zscaler_cloud=BETA
        break
        ;;
        6)
            echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected"
            zscaler_cloud=PREVIEW
        break
        ;;
        *) 
            echo "${RED}Invalid response. Please enter a number selection${RESET}"
        esac
    done
fi

if [[ "$oper" == "up" ]]; then
    if [[ -e ./.zsacrc ]]; then
        echo "${YELLOW}Existing deployment configuration file identified...${RESET}"
        # initialize environment variables
        . ./.zsacrc
        echo "Refreshing Deployment Type: ${GREEN}$dtype${RESET}..." 
    else #Prompt for deployment selection
        PS3="${CYAN}Select desired deployment: ${RESET}"
        deployments=("greenfield - Recommended for isolated test/POV deployments. Creates new network infrastructure and a public jump host" "brownfield - Recommended for prod deployments. Bring-your-own existing network infrastructure customizations + no bastion creation")
        select deployment in "${deployments[@]}"
        do
            case $REPLY in
                1)
                    echo "${GREEN}Greenfield deployment selected...${RESET}"
                    echo "${YELLOW}**Caution** These deployments include a publicly accessible jump host and is intended primarily for lab/test environments${RESET}"
                    echo ""
                    deployment=greenfield
                break
                ;;
                2)
                    echo "${GREEN}Brownfield deployment selected...${RESET}"
                    deployment=brownfield
                break
                ;;
                *) 
                    echo "${RED}Invalid response. Please enter a number selection${RESET}"
            esac
        done

        while true; do
            read -r -p "${CYAN}Deploy App Connectors in Auto Scaling VMSS? [yes/no]: ${RESET}" response
            case $response in 
                yes|y )
                    if [[ "$deployment" == "greenfield" ]]; then 
                        echo "${GREEN}Proceeding with greenfield Virtual Machine Scale Sets configuration...${RESET}"
                        vmss_enabled=true
                    elif [[ "$deployment" == "brownfield" ]]; then
                        echo "${GREEN}Proceeding with brownfield (ac_vmss) Virtual Machine Scale Sets configuration...${RESET}"
                        vmss_enabled=true
                        #implicitly set dtype as ac_vmss for brownfield + vmss
                        dtype=ac_vmss
                    fi
                break
                ;;
                no|n )
                    if [[ "$deployment" == "greenfield" ]]; then 
                        echo "${GREEN}Proceeding with greenfield manual scaling configuration...${RESET}"
                        vmss_enabled=false
                    elif [[ "$deployment" == "brownfield" ]]; then
                        echo "${GREEN}Proceeding with brownfield (ac) manual scaling configuration...${RESET}"
                        vmss_enabled=false
                        #implicitly set dtype as ac brownfield + no vmss
                        dtype=ac
                    fi
                break
                ;;
                    * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
            esac
        done
    fi

    if [[ "$deployment" == "greenfield" ]]; then
        PS3="${CYAN}Select desired deployment type: ${RESET}"
        if [[ "$vmss_enabled" == "false" ]]; then
            dtypes=(
                "Deploy 1 or more App Connectors in a new Resource Group and VNet"
                "Deploy a new Resource Group, VNet, and Bastion Host only - No App Connector resources"  
            )
            select greenfield_type in "${dtypes[@]}"
            do
                case $REPLY in
                    1)
                        echo "Deployment type base_ac selected..."
                        dtype=base_ac
                    break
                    ;;
                    2)
                        echo "Deployment type base selected..."
                        dtype=base
                    break
                    ;;
                    *) 
                        echo "${RED}Invalid response. Please enter a number selection${RESET}"
                esac
            done
        elif [[ "$vmss_enabled" == "true" ]]; then
            echo "Deployment type base_ac_vmss selected..."
            dtype=base_ac_vmss
        fi
    else
        dtype=$dtype
    fi
fi

echo "Discovering processor architecture..."
archdetect=$(uname -m)

tversion=1.1.9
echo "Detecting OS..."
if [[ "$OSTYPE" == "linux"* ]]; then
    os_str=linux
    arch=amd64
    ostype=Linux
elif [[ "$OSTYPE" == "darwin"* && $archdetect == "arm64" ]]; then
    os_str=darwin
    arch=arm64
    ostype=MacOS_arm64
elif [[ "$OSTYPE" == "darwin"* ]]; then
    os_str=darwin
    arch=amd64
    ostype=MacOS
elif [[ "$OSTYPE" == "freebsd"* ]]; then
    os_str=freebsd
    arch=amd64
    ostype=FreeBSD
    echo "FreeBSD support coming soon..."
    exit 1
else
    echo "${RED}Unsupported OS: $OSTYPE${RESET}"
    exit 1
fi
echo "${GREEN}OS is $ostype${RESET}"

dir=bin
echo "Creating a local $dir directory if not present..."
if [[ ! -e $dir ]]; then
    mkdir $dir
elif [[ ! -d $dir ]]; then
    echo "${RED}$dir already exists but is not a directory${RESET}" 1>&2
    exit 1
fi

echo "Checking Azure Environment Variables and App Connector bootstrap requirements... For custom/byo deployments, please stop and refer to the README and terraform.tfvars file instructions"
if [[ "$oper" == "up" && ! -e ./.zsacrc ]]; then
first_run="yes"
    echo "export zscaler_cloud='$zscaler_cloud'" > .zsacrc   
    # Azure Region selection
    PS3="${CYAN}Select desired Azure region: ${RESET}"
    region_list=(
	"australiacentral"
	"australiacentral2"
	"australiaeast"
	"australiasoutheast"
	"brazilsouth"
	"brazilsoutheast"
	"canadacentral"
	"canadaeast"
	"centralindia"
	"centralus"
	"centraluseuap"
	"eastasia"
	"eastus"
	"eastus2"
	"eastus2euap"
	"francecentral"
	"francesouth"
	"germanynorth"
	"germanywestcentral"
	"japaneast"
	"japanwest"
	"koreacentral"
	"koreasouth"
	"northcentralus"
	"northeurope"
	"norwayeast"
	"norwaywest"
	"southafricanorth"
	"southafricawest"
	"southcentralus"
	"southeastasia"
	"southindia"
	"swedencentral"
	"swedensouth"
	"switzerlandnorth"
	"switzerlandwest"
	"uaecentral"
	"uaenorth"
	"uksouth"
	"ukwest"
	"usdodcentral"
	"usdodeast"
	"usgovarizona"
	"usgovtexas"
	"usgovvirginia"
	"usseceast"
	"ussecwest"
	"ussecwestcentral"
	"westcentralus"
	"westeurope"
	"westindia"
	"westus"
	"westus2"
	"westus3"
    )
    select region_selection in "${region_list[@]}"; do
        for region_choice in "${region_list[@]}"; do
            if [[ $region_choice == $region_selection ]]; then
                azure_location=$region_selection
                echo "Azure region ${GREEN}$azure_location${RESET} selected..."
                echo "export TF_VAR_arm_location='$azure_location'" >> .zsacrc
                #Azure China not supported. leaving code for future use
		        if [[ ${azure_location} = "china"*  ]]; then
            		echo "${YELLOW}Azure China region detected. Setting ARM_ENVIRONMENT...${RESET}"
            		echo "export ARM_ENVIRONMENT=china" >> .zsacrc
            		echo "export ARM_SKIP_PROVIDER_REGISTRATION=true" >> .zsacrc
        	    elif [[ ${azure_location} = "usgov"* || ${azure_location} = "ussec"* || ${azure_location} = "usdod"* ]]; then
            		echo "${YELLOW} US Gov region detected. Setting ARM_ENVIRONMENT...${RESET}"
           	        echo "export ARM_ENVIRONMENT=usgovernment" >> .zsacrc
            		echo "export ARM_SKIP_PROVIDER_REGISTRATION=true" >> .zsacrc
        	    fi
                break 2
            fi
        done
    done

    echo "Checking Azure Environment Variables..."
    read -r -p "${CYAN}Enter Azure Subcription ID: ${RESET}" azure_subscription_id
    echo "export ARM_SUBSCRIPTION_ID=${azure_subscription_id}" >> .zsacrc
    echo "export TF_VAR_env_subscription_id=${azure_subscription_id}" >> .zsacrc
    read -r -p "${CYAN}Enter Directory (tenant) ID: ${RESET}" azure_tenant_id
    echo "export ARM_TENANT_ID=${azure_tenant_id}" >> .zsacrc
    read -r -p "${CYAN}Enter Application (client) ID of Service Principal: ${RESET}" azure_client_id
    echo "export ARM_CLIENT_ID=${azure_client_id}" >> .zsacrc
    read -r -p "${CYAN}Enter Client Secret Value of Service Principal: ${RESET}" azure_client_secret
    echo "export ARM_CLIENT_SECRET='${azure_client_secret}'" >> .zsacrc

    if [[ "$deployment" == "greenfield" ]]; then    
        while true; do
            clientpublicip=$(curl -s ifconfig.me)
            echo "greenfield deployments include a publicly accessible ssh bastion host.."
            read -r -p "${CYAN}Your current public IP is ${clientpublicip}. Restrict SSH access to only this IP address? [yes/no]: ${RESET}" bastion_response
            case $bastion_response in 
            yes|y ) 
                echo "Updating Bastion NSG to permit SSH only from ${clientpublicip}: "
                echo "export TF_VAR_bastion_nsg_source_prefix=${clientpublicip}" >> .zsacrc
                useclientip=true
            break
            ;;
            no|n )
                useclientip=false
            break
            ;;
            * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
            esac
        done

        if [[ "$useclientip" == "false" ]]; then
            while true; do
                read -r -p "${CYAN}Lock SSH access to a different IP address or range? Default is open [yes/no]: ${RESET}" changebastionip
                case $changebastionip in 
	            yes|y ) 
                    read -r -p "${CYAN}Enter new IP Address or CIDR range (e.g. 2.2.2.2/32): ${RESET}" bastionipinput
                    echo "export TF_VAR_bastion_nsg_source_prefix=${bastionipinput}" >> .zsacrc

                    if [[ $bastionipinput =~ ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(3[0-2]|[1-2][0-9]|[1-9]))$ ]]
                    then
                        echo "$bastionipinput - IP/Netmask valid"
                    else
                        echo "${RED}$bastionipinput is not valid IP CIDR format${RESET}"
                        echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                        exit 1
                    fi
                break
                ;;
	            no|n )
                    echo "${YELLOW}**Caution** SSH access permitted for all IP addresses...${RESET}" 
                break
                ;;
	            * ) echo "${RED}invalid response. Please enter yes or no${RESET}";;
                esac
            done
        fi
    fi

    # if .zsacrc is not present we'll assume that Azure env was never set
    if [[ "$dtype" != "base" ]]; then
        # ---
        # Host Encryption Support
        encryption_at_host_enabled=true
        # Sourcing .zsacrc to use credentials during execution
        source .zsacrc
        if grep -q "export ARM_ENVIRONMENT=china" .zsacrc; then
        TOKEN_ENDPOINT="https://login.partner.microsoftonline.cn/${ARM_TENANT_ID}/oauth2/token"
        RESOURCE="https://management.chinacloudapi.cn"
        elif grep -q "export ARM_ENVIRONMENT=usgovernment" .zsacrc; then
        TOKEN_ENDPOINT="https://login.microsoftonline.us/${ARM_TENANT_ID}/oauth2/token"
        RESOURCE="https://management.usgovcloudapi.net"
        else
        TOKEN_ENDPOINT="https://login.microsoftonline.com/${ARM_TENANT_ID}/oauth2/token"
        RESOURCE="https://management.azure.com/"
        fi

        while true; do
            read -r -p "${CYAN}Do you want to enable the Azure host encryption feature? [Default setting is Yes]: ${RESET}" input

            # Convert the user input to lowercase for case-insensitive comparison
            input=$(echo "$input" | tr '[:upper:]' '[:lower:]')

            if [[ "$input" == "no" || "$input" == "n" ]]; then
                echo "${YELLOW}**Caution** Setting encryption_at_host_enabled to false...${RESET}"
                encryption_at_host_enabled=false
                break
            elif [[ "$input" == "yes" || "$input" == "y" || -z "$input" ]]; then            
                echo "Checking if EncryptionAtHost feature is enabled for subscription $ARM_SUBSCRIPTION_ID..."
                ACCESS_TOKEN=$(curl -s -X POST -H "Content-Type: application/x-www-form-urlencoded" \
                    -d "grant_type=client_credentials" \
                    -d "client_id=${ARM_CLIENT_ID}" \
                    -d "client_secret=${ARM_CLIENT_SECRET}" \
                    -d "resource=${RESOURCE}" \
                    "${TOKEN_ENDPOINT}" | grep -o '"access_token":"[^"]*' | awk -F'"' '{print $4}')
                    
                response=$(curl -s -X GET -H "Authorization: Bearer ${ACCESS_TOKEN}" \
                    "$RESOURCE/subscriptions/$ARM_SUBSCRIPTION_ID/providers/Microsoft.Features/providers/Microsoft.Compute/features/EncryptionAtHost?api-version=2021-07-01" \
                    |grep -o '"state":"[^"]*' | awk -F'"' '{print $4}')

                if [ "$response" = "Registered" ]; then
                    echo "${GREEN}Setting encryption_at_host_enabled to true...${RESET}"
                    encryption_at_host_enabled=true
                else
                    echo "${RED}Error: Azure Subscription $ARM_SUBSCRIPTION_ID is not registered to support host encryption. Please refer to documentation.${RESET}"
                    exit 1    
                fi
                break
            else
                echo "${RED}Invalid input. Please enter 'yes' or 'no'.${RESET}"
            fi
        done

        echo "export TF_VAR_encryption_at_host_enabled=${encryption_at_host_enabled}" >> .zsacrc
        # End of Host Encryption support update
        # ---

        while true; do
            read -r -p "${CYAN}Enter ZPA Client ID: ${RESET}" zpa_client_id
            echo "export ZPA_CLIENT_ID=\"${zpa_client_id}\"" >> .zsacrc
            read -r -p "${CYAN}Enter ZPA Client Secret: ${RESET}" zpa_client_secret
            echo "export ZPA_CLIENT_SECRET=\"${zpa_client_secret}\"" >> .zsacrc
            read -r -p "${CYAN}Enter ZPA Customer ID: ${RESET}" zpa_customer_id
            echo "export ZPA_CUSTOMER_ID=\"${zpa_customer_id}\"" >> .zsacrc

            read -r -p "${CYAN}Do you already have an App Connector provisioning key to use? [yes/no]: ${RESET}" prov_key_response
            case $prov_key_response in 
                yes|y ) 
                    read -r -p "${CYAN}Enter the name of your existing App Connector provisioning key: ${RESET}" byo_provisioning_key_name
                    echo "export TF_VAR_byo_provisioning_key=true" >> .zsacrc
                    echo "export TF_VAR_byo_provisioning_key_name=${byo_provisioning_key_name}" >> .zsacrc
                break
                ;;
                no|n )
                    echo "${GREEN}Terraform will be creating a new App Connector Group and provisioning key${RESET}"
                    echo "${YELLOW}Before proceeding, make sure you have entered all variable requirements from steps 1 and 2 in $dtype/terraform.tfvars${RESET}"
                break
                ;;
                * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
            esac
        done

        acvm_instance_type_default=Standard_D4s_v5
        echo "${CYAN}Available VM types:${RESET}"
        echo "  ${GREEN}4-core Intel (Zscaler recommended):${RESET} Standard_F4s_v2, Standard_D4s_v3, Standard_D4s_v4, Standard_D4s_v5"
        echo "  ${GREEN}4-core AMD (cost-optimized):${RESET} Standard_D4as_v5"
        echo "  ${GREEN}8-core Intel (AppProtection):${RESET} Standard_D8s_v5"
        echo "  ${GREEN}8-core AMD (AppProtection, cost-optimized):${RESET} Standard_D8as_v5"
        while true; do
            read -r -p "${CYAN}Enter desired Azure VM type for AC. [Default=$acvm_instance_type_default]: ${RESET}" acvm_instance_type_input
            acvm_instance_type=${acvm_instance_type_input:-$acvm_instance_type_default}
            case $acvm_instance_type in 
                Standard_F4s_v2|Standard_D4s_v3|Standard_D4s_v4|Standard_D4s_v5|Standard_D4as_v5|Standard_D8s_v5|Standard_D8as_v5 ) 
                    echo "${GREEN}App Connector VM type: ${acvm_instance_type} selected...${RESET}"
                    echo "export TF_VAR_acvm_instance_type=${acvm_instance_type}" >> .zsacrc
                break
                ;;
                *)
                    echo "${RED}Invalid App Connector VM type: ${acvm_instance_type}. Please enter an approved VM type${RESET}"
            esac
        done 

        ac_count_default=2
        if [[ "$dtype" != *"vmss"* ]]; then
            read -r -p "${CYAN}Enter how many App Connectors to deploy? [Default=$ac_count_default]: ${RESET}" ac_count_input
            ac_count=${ac_count_input:-$ac_count_default}
            if ((ac_count >= 1 && ac_count <= 10)); then
                echo "${dtype} will deploy ${ac_count} App Connector in ${azure_location}"
                echo "export TF_VAR_ac_count=${ac_count}" >> .zsacrc
            else
                echo "${RED}Invalid ac_count value. Must be a number between 1 and 10${RESET}"
                echo "Delete .zsacrc file and re-run zsac up..."
                exit 1
            fi
        fi

        az_supported_regions=["australiaeast","brazilsouth","canadacentral","centralindia","centralus","eastasia","eastus","eastus2","francecentral","germanywestcentral","japaneast","koreacentral","northeurope","norwayeast","southafricanorth","southcentralus","southeastasia","swedencentral","switzerlandnorth","uaenorth","uksouth","westeurope","westus2","westus3"]
        if [[ ${az_supported_regions[*]} =~ $azure_location ]]; then
            echo "${GREEN}Azure region ${azure_location} supports Zones deployment...${RESET}"
            zones_enabled_default=no
            while true; do
                read -r -p "${CYAN}Deploy App Connectors in dedicated Availability Zones/subnets? (Enter yes or no) [Default=$zones_enabled_default]: ${RESET}" zones_enabled_input
                zones_enabled=${zones_enabled_input:-$zones_enabled_default}
                case $zones_enabled in 
                yes|y )
                    echo "export TF_VAR_zones_enabled=true" >> .zsacrc
                    zones_enabled=true
                break
                ;;
                no|n )
                    echo "export TF_VAR_zones_enabled=false" >> .zsacrc
                    echo "${YELLOW}**Caution** No zones defined. Proceeding with availability sets fault tolerance...${RESET}"
                    break
                ;;
                * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
                esac
            done  
        else
            echo "${YELLOW}Azure region ${azure_location} does not support Zones. Proceeding...${RESET}"
        fi

        # Azure number of Availability Zones selection
        if [[ "$zones_enabled" == "true" ]]; then
            PS3="${CYAN}Select how many Availability Zone subnets to deploy across: ${RESET}"
            zones_list=(
                "1 availability zone"
                "2 availability zones"
                "3 availability zones"
            )
            select zone_selection in "${zones_list[@]}"
            do
                case $REPLY in
                1 )
                    echo "${GREEN}One Availability Zone selected...${RESET}"
                    zones_count=1
                break
                ;;
                2 )
                    echo "${GREEN}Two Availability Zones selected...${RESET}"
                    zones_count=2
                break
                ;;
                3 )
                    echo "${GREEN}Three Availability Zones selected...${RESET}"
                    zones_count=3
                break
                ;;
                *) 
                    echo "${RED}Invalid response. Please enter a number selection${RESET}"
                esac
            done
        fi

        if [[ "$zones_count" < 3 ]]; then
           PS3="${CYAN}Select which availablity zones to deploy across: ${RESET}"
            if [[ "$zones_count" == 1 ]]; then
                zones_options=(
                    "Zone 1"
                    "Zone 2"
                    "Zone 3"
                )
                select zones_selection in "${zones_options[@]}"
                do
                    case $REPLY in
                    1 )
                        echo "${GREEN}App Connector resources will be deployed in AZ 1${RESET}"
                        echo "export TF_VAR_zones='[\"1\"]'" >> .zsacrc
                    break
                    ;;
                    2 )
                        echo "${GREEN}App Connector resources will be deployed in AZ 2${RESET}"
                        echo "export TF_VAR_zones='[\"2\"]'" >> .zsacrc
                    break
                    ;;
                    3 )
                        echo "${GREEN}App Connector resources will be deployed in AZ 3${RESET}"
                        echo "export TF_VAR_zones='[\"3\"]'" >> .zsacrc
                    break
                    ;;
                    *) 
                        echo "${RED}Invalid response. Please enter a number selection${RESET}"
                    esac
                done
            else
                zones_options=(
                    "Zones 1 and 2"
                    "Zones 1 and 3"
                    "Zones 2 and 3"
                )
                select zones_selection in "${zones_options[@]}"
                do
                    case $REPLY in
                    1 )
                        echo "${GREEN}App Connector resources will be deployed in AZ 1 and AZ 2${RESET}"
                        echo "export TF_VAR_zones='[\"1\", \"2\"]'" >> .zsacrc
                    break
                    ;;
                    2 )
                        echo "${GREEN}App Connector resources will be deployed in AZ 1 and AZ 3${RESET}"
                        echo "export TF_VAR_zones='[\"1\", \"3\"]'" >> .zsacrc
                    break
                    ;;
                    3 )
                        echo "${GREEN}App Connector resources will be deployed in AZ 2 and AZ 3${RESET}"
                        echo "export TF_VAR_zones='[\"2\", \"3\"]'" >> .zsacrc
                    break
                    ;;
                    *) 
                        echo "${RED}Invalid response. Please enter a number selection${RESET}"
                    esac
                done
            fi
        else
            echo "${GREEN}App Connector resources will be deployed in AZ 1, AZ 2 and AZ 3${RESET}"
            echo "export TF_VAR_zones='[\"1\", \"2\", \"3\"]'" >> .zsacrc
        fi

        # VMSS specific inputs
        if [[ $dtype == *"vmss"* ]]; then
            if [[ "$zones_enabled" == "true" ]]; then
                echo "${GREEN}Explicit Availability Zones based deployed detected... Terraform will create a total of $zones_count VMSS; one per designated AZ${RESET}"
            else
                echo "${GREEN}No explicit Availability Zones were specified... Terraform will create a single VMSS${RESET}"
            fi
            #########################################
            # Min/Default/Max VMSS Configuration
            #########################################
            # min count
            vmss_min_default=2
            read -r -p "${CYAN}Enter the minimum amount of App Connectors per VMSS? [Default=$vmss_min_default]: ${RESET}" vmss_min_input
            vmss_min=${vmss_min_input:-$vmss_min_default}
            if (( $vmss_min < 1 || $vmss_min > 10 )); then
                echo "${RED}Invalid vmss_min value. Must be a number between 1 and 10${RESET}"
                echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                exit 1
            fi

            # default count
            vmss_default_default=2
            read -r -p "${CYAN}Enter the default amount of App Connectors per VMSS? [Default=$vmss_default_default]: ${RESET}" vmss_default_input
            vmss_default=${vmss_default_input:-$vmss_default_default}
            if (( $vmss_default < 1 || $vmss_default > 10 )); then
                echo "${RED}Invalid vmss_default value. Must be a number between 1 and 10${RESET}"
                echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                exit 1
            fi

            # max count
            vmss_max_default=10
            read -r -p "${CYAN}Enter the maximum amount of App Connectors per VMSS? [Default=$vmss_max_default]: ${RESET}" vmss_max_input
            vmss_max=${vmss_max_input:-$vmss_max_default}
            if (( $vmss_max < 1 || $vmss_max > 10 )); then
                echo "${RED}Invalid vmss_max value. Must be a number between 1 and 10${RESET}"
                echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                exit 1
            fi

            # validate values
            if (( $vmss_default < $vmss_min || $vmss_default > $vmss_max )); then
                echo "${RED}Invalid vmss_default value. Must be a number between vmss_min and vmss_max${RESET}"
                echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                exit 1
            fi

            if [[ "$zones_enabled" == "true" ]]; then
                echo "${GREEN}${dtype} will deploy $zones_count VMSS each with min: ${vmss_min} default: ${vmss_default} max: ${vmss_max} App Connectors in ${azure_location}${RESET}"
            else
                echo "${GREEN}${dtype} will deploy 1 VMSS with min: ${vmss_min} default: ${vmss_default} max: ${vmss_max} App Connectors in ${azure_location}${RESET}"
            fi
            echo "export TF_VAR_vmss_min_acs=${vmss_min}" >> .zsacrc
            echo "export TF_VAR_vmss_default_acs=${vmss_default}" >> .zsacrc
            echo "export TF_VAR_vmss_max_acs=${vmss_max}" >> .zsacrc

            #########################################
            # Scale In/Out Threshold Configuration
            #########################################
            # Scale In threshold count
            scale_in_default=30
            read -r -p "${CYAN}Enter the scale in threshold for scale sets? This value refers to percent CPU utilization. [Default=$scale_in_default]: ${RESET}" scale_in_input
            scale_in=${scale_in_input:-$scale_in_default}
            if (( $scale_in < 1 || $scale_in > 100 )); then
                echo "${RED}Invalid scale_in value. Must be a number between 1 and 100${RESET}"
                echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                exit 1
            fi

            # Scale Out threshold count
            scale_out_default=70
            read -r -p "${CYAN}Enter the scale out threshold for scale sets? This value refers to percent CPU utilization. [Default=$scale_out_default]: ${RESET}" scale_out_input
            scale_out=${scale_out_input:-$scale_out_default}
            if (( $scale_out < 1 || $scale_out > 100 || $scale_out <= $scale_in)); then
                echo "${RED}Invalid scale_out value. Must be a number between 1 and 100 and be greater than scale_in value${RESET}"
                echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                exit 1
            fi

            echo "export TF_VAR_scale_in_threshold=${scale_in}" >> .zsacrc
            echo "export TF_VAR_scale_out_threshold=${scale_out}" >> .zsacrc

            #########################################
            # Scheduled Scaling Configuration
            #########################################
            # enable/disable scheduled scaling
            while true; do
                read -r -p "${CYAN}Do you want to enable scheduled scaling on the VMSS? [yes/no]: ${RESET}" response
                case $response in 
                no|n ) 
                    echo "${GREEN}Skipping scheduled scaling configuration...${RESET}"
                break
                ;;
                yes|y )
                # min count
                    vmss_sched_min_default=2
                    read -r -p "${CYAN}Enter the minimum amount of scheduled App Connectors in VMSS? [Default=$vmss_sched_min_default]: ${RESET}" vmss_sched_min_input
                    vmss_sched_min=${vmss_sched_min_input:-$vmss_sched_min_default}
                    if (( $vmss_sched_min < 1 || $vmss_sched_min > 20 )); then
                        echo "${RED}Invalid vmss_sched_min value. Must be a number between 1 and 20${RESET}"
                        echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                        exit 1
                    elif (( $vmss_sched_min > $vmss_max )); then
                        echo "${RED}Invalid vmss_sched_min value. Must be a number between less than or equal to vmss_max${RESET}"
                        echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                        exit 1
                    fi

                    # days of the week
                    days_of_week=()
                    potential_days_of_week=("Sunday" "Monday" "Tuesday" "Wednesday" "Thursday" "Friday "Saturday)
                    for day in ${potential_days_of_week[@]}; do
                        while true; do
                            read -r -p "${CYAN}Apply Scheduled Scaling Policy on ${day}? [yes/no]: ${RESET}" resp
                            case $resp in 
                            no|n ) 
                                echo "${GREEN}Not configuring ${day} on Scheduled Scaling configuration...${RESET}"
                            break
                            ;;
                            yes|y )
                                echo "${GREEN}Adding ${day} on Scheduled Scaling configuration...${RESET}"
                                days_of_week+=($day)
                            break
                            ;;
                            * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
                            esac
                        done
                    done
                    #format days of week array into list
                    days_of_week_str="'["
                    print_str=""
                    for day in ${days_of_week[@]}; do
                        days_of_week_str+="\"${day}\", "
                        print_str+="${day} "
                    done
                    days_of_week_str+="]'"
                    echo "${GREEN}Configuring the following days on the Scheduled Scaling Policy: ${print_str}${RESET}"
                        
                    # start time hour
                    start_hour_default=9
                    read -r -p "${CYAN}Enter the start time hour for the scheduled scaling configuration? [Default=$start_hour_default]: ${RESET}" start_hour_input
                    start_hour=${start_hour_input:-$start_hour_default}
                    if (( $start_hour < 0 || $start_hour > 23 )); then
                        echo "${RED}Invalid start_hour value. Must be a number between 0 and 23${RESET}"
                        echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                        exit 1
                    fi
                    # start time minute
                    start_min_default=0
                    read -r -p "${CYAN}Enter the start time min for the scheduled scaling configuration? [Default=$start_min_default]: ${RESET}" start_min_input
                    start_min=${start_min_input:-$start_min_default}
                    if (( $start_min < 0 || $start_min > 59 )); then
                        echo "${RED}Invalid start_min value. Must be a number between 0 and 59${RESET}"
                        echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                        exit 1
                    fi
                    # end time hour
                    end_hour_default=17
                    read -r -p "${CYAN}Enter the end time hour for the scheduled scaling configuration? [Default=$end_hour_default]: ${RESET}" end_hour_input
                    end_hour=${end_hour_input:-$end_hour_default}
                    if (( $end_hour < 0 || $end_hour > 23 )); then
                        echo "${RED}Invalid end_hour value. Must be a number between 0 and 23${RESET}"
                        echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                        exit 1
                    fi
                    # end time minute
                    end_min_default=30
                    read -r -p "${CYAN}Enter the end time min for the scheduled scaling configuration? [Default=$end_min_default]: ${RESET}" end_min_input
                    end_min=${end_min_input:-$end_min_default}
                    if (( $end_min < 0 || $end_min > 59 )); then
                        echo "${RED}Invalid end_min value. Must be a number between 0 and 59${RESET}"
                        echo "${YELLOW}Delete .zsacrc file and re-run zsac up...${RESET}"
                        exit 1
                    fi

                    echo "export TF_VAR_scheduled_scaling_enabled=true" >> .zsacrc
                    echo "export TF_VAR_scheduled_scaling_vmss_min_acs=${vmss_sched_min}" >> .zsacrc
                    echo "export TF_VAR_scheduled_scaling_days_of_week=${days_of_week_str}" >> .zsacrc
                    echo "export TF_VAR_scheduled_scaling_start_time_hour=${start_hour}" >> .zsacrc
                    echo "export TF_VAR_scheduled_scaling_start_time_min=${start_min}" >> .zsacrc
                    echo "export TF_VAR_scheduled_scaling_end_time_hour=${end_hour}" >> .zsacrc
                    echo "export TF_VAR_scheduled_scaling_end_time_min=${end_min}" >> .zsacrc
                break
                ;;
                * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
                esac
            done
        fi
    fi
fi

# add local bin directory to PATH
if ! grep -Fxq "export PATH=\${PATH}:\${PWD}/bin" .zsacrc; then
    echo 'export PATH=${PATH}:${PWD}/bin' >> .zsacrc
fi

# add deployment type to .zsacrc for future runs
if [[ "$oper" == "up" ]]; then
    echo "${GREEN}Updating .zsacrc with dtype of $dtype${RESET}"
    sed -i'' -e '/dtype/d' .zsacrc
    echo "export dtype=${dtype}" >> .zsacrc
fi

# initialize environment variables
. ./.zsacrc

# check for valid environment variables in .zsacrc
if [ -z "$ARM_CLIENT_ID" ] || [ -z "$ARM_CLIENT_SECRET" ] || [ -z "$ARM_SUBSCRIPTION_ID" ] || [ -z "$ARM_TENANT_ID" ] || [ -z "$TF_VAR_arm_location" ]; then
    echo "${RED}Azure Access info is missing. Remove .zsacrc file and rerun $0 $1${RESET}"
    exit 1
fi

echo "Download terraform binary for $ostype if not present..."
if [[ ! -e ./$dir/terraform ]]; then
    curl -o ./$dir/terraform_${tversion}_${arch}.zip https://releases.hashicorp.com/terraform/$tversion/terraform_${tversion}_${os_str}_${arch}.zip
    unzip ./$dir/terraform_${tversion}_${arch}.zip -d ./$dir
    rm -f ./$dir/terraform_${tversion}_${arch}.zip
fi

if [[ "$oper" == "do" ]]; then
    exit 1
fi

# Terraform apply/destroy
if [[ "$oper" == "up" ]]; then
    echo "${GREEN}Bringing up App Connector cluster...${RESET}"
    TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" init
    if [[ "$AUTO_APPROVE" ]]; then
        TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" apply -auto-approve
    else
        TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" apply
    fi

elif [[ "$oper" == "destroy" ]]; then
    echo "${GREEN}Destroying App Connector cluster...${RESET}"
    TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" init
    if [[ "$AUTO_APPROVE" ]]; then
        TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" destroy -auto-approve
    else
      TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" destroy
    fi
    echo "${GREEN}Removing Terraform files and directories...${RESET}"
    rm -rf bin 
    rm -rf **/.terraform/* && rm -rf **/.terraform*
    find . -type f -name '.terraform.lock.hcl' -delete
    rm -rf .terraform* && rm -f terraform.tfstate*
    rm -f *.pem && rm -f *.pem.pub
    rm -f name_prefix random_string
    rm -rf user.key user.crt
    rm -rf systems.json setup-*.tar
    rm -rf **/errorlog.txt
    now=$(date +'%Y-%m-%d-%H_%M_%S')
    echo "${GREEN}archiving .zsacrc file to .zsacrc-${now}${RESET}"
    cp .zsacrc .zsacrc-${now}
    rm -rf .zsacrc && rm -rf .zsacrc.bak
fi
